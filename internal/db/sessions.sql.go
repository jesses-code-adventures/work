// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (id, client_id, start_time, description, hourly_rate)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id, client_id, start_time, end_time, description, created_at, updated_at, hourly_rate, full_work_summary, outside_git
`

type CreateSessionParams struct {
	ID          string          `db:"id" json:"id"`
	ClientID    string          `db:"client_id" json:"client_id"`
	StartTime   time.Time       `db:"start_time" json:"start_time"`
	Description sql.NullString  `db:"description" json:"description"`
	HourlyRate  sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.ClientID,
		arg.StartTime,
		arg.Description,
		arg.HourlyRate,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
	)
	return i, err
}

const deleteAllSessions = `-- name: DeleteAllSessions :exec
DELETE FROM sessions
`

func (q *Queries) DeleteAllSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllSessions)
	return err
}

const deleteSessionsByDateRange = `-- name: DeleteSessionsByDateRange :exec
DELETE FROM sessions
WHERE (?1 IS NULL OR start_time >= ?1) 
  AND (?2 IS NULL OR start_time <= ?2)
`

type DeleteSessionsByDateRangeParams struct {
	StartDate interface{} `db:"start_date" json:"start_date"`
	EndDate   interface{} `db:"end_date" json:"end_date"`
}

func (q *Queries) DeleteSessionsByDateRange(ctx context.Context, arg DeleteSessionsByDateRangeParams) error {
	_, err := q.db.ExecContext(ctx, deleteSessionsByDateRange, arg.StartDate, arg.EndDate)
	return err
}

const getActiveSession = `-- name: GetActiveSession :one
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.end_time IS NULL
ORDER BY s.start_time DESC
LIMIT 1
`

type GetActiveSessionRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetActiveSession(ctx context.Context) (GetActiveSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveSession)
	var i GetActiveSessionRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
		&i.ClientName,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.id = ?1
`

type GetSessionByIDRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionByID(ctx context.Context, id string) (GetSessionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i GetSessionByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
		&i.ClientName,
	)
	return i, err
}

const getSessionsByClient = `-- name: GetSessionsByClient :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE c.name = ?1
ORDER BY s.start_time DESC
`

type GetSessionsByClientRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsByClient(ctx context.Context, clientName string) ([]GetSessionsByClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByClient, clientName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsByClientRow
	for rows.Next() {
		var i GetSessionsByClientRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByDateRange = `-- name: GetSessionsByDateRange :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.start_time >= ?1 AND s.start_time <= ?2
ORDER BY s.start_time DESC
`

type GetSessionsByDateRangeParams struct {
	StartDate time.Time `db:"start_date" json:"start_date"`
	EndDate   time.Time `db:"end_date" json:"end_date"`
}

type GetSessionsByDateRangeRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsByDateRange(ctx context.Context, arg GetSessionsByDateRangeParams) ([]GetSessionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsByDateRangeRow
	for rows.Next() {
		var i GetSessionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsWithoutDescription = `-- name: GetSessionsWithoutDescription :many
select s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
from sessions s
join clients c on s.client_id = c.id
where s.end_time is not null 
  and (s.description is null or s.description = '')
  and (?1 is null or c.name = ?1)
  and (?2 is null or s.id = ?2)
order by s.start_time desc
`

type GetSessionsWithoutDescriptionParams struct {
	ClientName interface{} `db:"client_name" json:"client_name"`
	SessionID  interface{} `db:"session_id" json:"session_id"`
}

type GetSessionsWithoutDescriptionRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsWithoutDescription(ctx context.Context, arg GetSessionsWithoutDescriptionParams) ([]GetSessionsWithoutDescriptionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsWithoutDescription, arg.ClientName, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsWithoutDescriptionRow
	for rows.Next() {
		var i GetSessionsWithoutDescriptionRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentSessions = `-- name: ListRecentSessions :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
ORDER BY s.start_time DESC
LIMIT ?1
`

type ListRecentSessionsRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) ListRecentSessions(ctx context.Context, limitCount int64) ([]ListRecentSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentSessions, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentSessionsRow
	for rows.Next() {
		var i ListRecentSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithDateRange = `-- name: ListSessionsWithDateRange :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE (?1 IS NULL OR s.start_time >= ?1) 
  AND (?2 IS NULL OR s.start_time <= ?2)
ORDER BY s.start_time DESC
LIMIT ?3
`

type ListSessionsWithDateRangeParams struct {
	StartDate  interface{} `db:"start_date" json:"start_date"`
	EndDate    interface{} `db:"end_date" json:"end_date"`
	LimitCount int64       `db:"limit_count" json:"limit_count"`
}

type ListSessionsWithDateRangeRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	StartTime       time.Time       `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime    `db:"end_time" json:"end_time"`
	Description     sql.NullString  `db:"description" json:"description"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	HourlyRate      sql.NullFloat64 `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString  `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString  `db:"outside_git" json:"outside_git"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) ListSessionsWithDateRange(ctx context.Context, arg ListSessionsWithDateRangeParams) ([]ListSessionsWithDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithDateRange, arg.StartDate, arg.EndDate, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSessionsWithDateRangeRow
	for rows.Next() {
		var i ListSessionsWithDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stopSession = `-- name: StopSession :one
UPDATE sessions
SET end_time = ?1
WHERE id = ?2
RETURNING id, client_id, start_time, end_time, description, created_at, updated_at, hourly_rate, full_work_summary, outside_git
`

type StopSessionParams struct {
	EndTime sql.NullTime `db:"end_time" json:"end_time"`
	ID      string       `db:"id" json:"id"`
}

func (q *Queries) StopSession(ctx context.Context, arg StopSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, stopSession, arg.EndTime, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
	)
	return i, err
}

const updateSessionDescription = `-- name: UpdateSessionDescription :one
UPDATE sessions
SET description = ?1, full_work_summary = ?2
WHERE id = ?3
RETURNING id, client_id, start_time, end_time, description, created_at, updated_at, hourly_rate, full_work_summary, outside_git
`

type UpdateSessionDescriptionParams struct {
	Description     sql.NullString `db:"description" json:"description"`
	FullWorkSummary sql.NullString `db:"full_work_summary" json:"full_work_summary"`
	ID              string         `db:"id" json:"id"`
}

func (q *Queries) UpdateSessionDescription(ctx context.Context, arg UpdateSessionDescriptionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, updateSessionDescription, arg.Description, arg.FullWorkSummary, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
	)
	return i, err
}

const updateSessionOutsideGit = `-- name: UpdateSessionOutsideGit :one
UPDATE sessions
SET outside_git = ?1
WHERE id = ?2
RETURNING id, client_id, start_time, end_time, description, created_at, updated_at, hourly_rate, full_work_summary, outside_git
`

type UpdateSessionOutsideGitParams struct {
	OutsideGit sql.NullString `db:"outside_git" json:"outside_git"`
	ID         string         `db:"id" json:"id"`
}

func (q *Queries) UpdateSessionOutsideGit(ctx context.Context, arg UpdateSessionOutsideGitParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, updateSessionOutsideGit, arg.OutsideGit, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HourlyRate,
		&i.FullWorkSummary,
		&i.OutsideGit,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expenses.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/shopspring/decimal"
)

const clearExpenseInvoiceIDs = `-- name: ClearExpenseInvoiceIDs :exec
UPDATE expenses 
SET invoice_id = NULL
WHERE invoice_id = ?1
`

func (q *Queries) ClearExpenseInvoiceIDs(ctx context.Context, invoiceID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, clearExpenseInvoiceIDs, invoiceID)
	return err
}

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (id, amount, expense_date, reference, client_id, invoice_id, description)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
RETURNING id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description
`

type CreateExpenseParams struct {
	ID          string          `db:"id" json:"id"`
	Amount      decimal.Decimal `db:"amount" json:"amount"`
	ExpenseDate time.Time       `db:"expense_date" json:"expense_date"`
	Reference   sql.NullString  `db:"reference" json:"reference"`
	ClientID    sql.NullString  `db:"client_id" json:"client_id"`
	InvoiceID   sql.NullString  `db:"invoice_id" json:"invoice_id"`
	Description sql.NullString  `db:"description" json:"description"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.ID,
		arg.Amount,
		arg.ExpenseDate,
		arg.Reference,
		arg.ClientID,
		arg.InvoiceID,
		arg.Description,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpenseDate,
		&i.Reference,
		&i.ClientID,
		&i.InvoiceID,
		&i.Description,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE FROM expenses
WHERE id = ?1
`

func (q *Queries) DeleteExpense(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteExpense, id)
	return err
}

const getExpenseByID = `-- name: GetExpenseByID :one
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE id = ?1
`

func (q *Queries) GetExpenseByID(ctx context.Context, id string) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpenseByID, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpenseDate,
		&i.Reference,
		&i.ClientID,
		&i.InvoiceID,
		&i.Description,
	)
	return i, err
}

const getExpensesByInvoiceID = `-- name: GetExpensesByInvoiceID :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE invoice_id = ?1
ORDER BY expense_date DESC
`

func (q *Queries) GetExpensesByInvoiceID(ctx context.Context, invoiceID sql.NullString) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByInvoiceID, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByReference = `-- name: GetExpensesByReference :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE reference = ?1
ORDER BY expense_date DESC
`

func (q *Queries) GetExpensesByReference(ctx context.Context, reference sql.NullString) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByReference, reference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesWithoutInvoiceByClient = `-- name: GetExpensesWithoutInvoiceByClient :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE client_id = ?1 AND invoice_id IS NULL
ORDER BY expense_date DESC
`

func (q *Queries) GetExpensesWithoutInvoiceByClient(ctx context.Context, clientID sql.NullString) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesWithoutInvoiceByClient, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesWithoutInvoiceByClientAndDateRange = `-- name: GetExpensesWithoutInvoiceByClientAndDateRange :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE client_id = ?1 
  AND invoice_id IS NULL
  AND expense_date >= ?2 
  AND expense_date <= ?3
ORDER BY expense_date DESC
`

type GetExpensesWithoutInvoiceByClientAndDateRangeParams struct {
	ClientID  sql.NullString `db:"client_id" json:"client_id"`
	StartDate time.Time      `db:"start_date" json:"start_date"`
	EndDate   time.Time      `db:"end_date" json:"end_date"`
}

func (q *Queries) GetExpensesWithoutInvoiceByClientAndDateRange(ctx context.Context, arg GetExpensesWithoutInvoiceByClientAndDateRangeParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesWithoutInvoiceByClientAndDateRange, arg.ClientID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpenses = `-- name: ListExpenses :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
ORDER BY expense_date DESC
`

func (q *Queries) ListExpenses(ctx context.Context) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensesByClient = `-- name: ListExpensesByClient :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE client_id = ?1
ORDER BY expense_date DESC
`

func (q *Queries) ListExpensesByClient(ctx context.Context, clientID sql.NullString) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpensesByClient, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensesByClientAndDateRange = `-- name: ListExpensesByClientAndDateRange :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE client_id = ?1 
  AND expense_date >= ?2 
  AND expense_date <= ?3
ORDER BY expense_date DESC
`

type ListExpensesByClientAndDateRangeParams struct {
	ClientID  sql.NullString `db:"client_id" json:"client_id"`
	StartDate time.Time      `db:"start_date" json:"start_date"`
	EndDate   time.Time      `db:"end_date" json:"end_date"`
}

func (q *Queries) ListExpensesByClientAndDateRange(ctx context.Context, arg ListExpensesByClientAndDateRangeParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpensesByClientAndDateRange, arg.ClientID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensesByDateRange = `-- name: ListExpensesByDateRange :many
SELECT id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description FROM expenses
WHERE expense_date >= ?1 AND expense_date <= ?2
ORDER BY expense_date DESC
`

type ListExpensesByDateRangeParams struct {
	StartDate time.Time `db:"start_date" json:"start_date"`
	EndDate   time.Time `db:"end_date" json:"end_date"`
}

func (q *Queries) ListExpensesByDateRange(ctx context.Context, arg ListExpensesByDateRangeParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpensesByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpenseDate,
			&i.Reference,
			&i.ClientID,
			&i.InvoiceID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses 
SET 
    amount = ?1,
    expense_date = ?2,
    reference = ?3,
    client_id = ?4,
    invoice_id = ?5,
    description = ?6
WHERE id = ?7
RETURNING id, amount, created_at, updated_at, expense_date, reference, client_id, invoice_id, description
`

type UpdateExpenseParams struct {
	Amount      decimal.Decimal `db:"amount" json:"amount"`
	ExpenseDate sql.NullTime    `db:"expense_date" json:"expense_date"`
	Reference   sql.NullString  `db:"reference" json:"reference"`
	ClientID    sql.NullString  `db:"client_id" json:"client_id"`
	InvoiceID   sql.NullString  `db:"invoice_id" json:"invoice_id"`
	Description sql.NullString  `db:"description" json:"description"`
	ID          string          `db:"id" json:"id"`
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, updateExpense,
		arg.Amount,
		arg.ExpenseDate,
		arg.Reference,
		arg.ClientID,
		arg.InvoiceID,
		arg.Description,
		arg.ID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpenseDate,
		&i.Reference,
		&i.ClientID,
		&i.InvoiceID,
		&i.Description,
	)
	return i, err
}

const updateExpenseInvoiceID = `-- name: UpdateExpenseInvoiceID :exec
UPDATE expenses 
SET invoice_id = ?1
WHERE id = ?2
`

type UpdateExpenseInvoiceIDParams struct {
	InvoiceID sql.NullString `db:"invoice_id" json:"invoice_id"`
	ID        string         `db:"id" json:"id"`
}

func (q *Queries) UpdateExpenseInvoiceID(ctx context.Context, arg UpdateExpenseInvoiceIDParams) error {
	_, err := q.db.ExecContext(ctx, updateExpenseInvoiceID, arg.InvoiceID, arg.ID)
	return err
}

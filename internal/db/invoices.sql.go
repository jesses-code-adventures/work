// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/shopspring/decimal"
)

const clearSessionInvoiceIDs = `-- name: ClearSessionInvoiceIDs :exec
UPDATE sessions
SET invoice_id = NULL
WHERE invoice_id = ?1
`

func (q *Queries) ClearSessionInvoiceIDs(ctx context.Context, invoiceID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, clearSessionInvoiceIDs, invoiceID)
	return err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (id, client_id, invoice_number, period_type, period_start_date, period_end_date, subtotal_amount, gst_amount, total_amount)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING id, client_id, invoice_number, period_type, period_start_date, period_end_date, subtotal_amount, gst_amount, total_amount, generated_date, created_at, updated_at
`

type CreateInvoiceParams struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, createInvoice,
		arg.ID,
		arg.ClientID,
		arg.InvoiceNumber,
		arg.PeriodType,
		arg.PeriodStartDate,
		arg.PeriodEndDate,
		arg.SubtotalAmount,
		arg.GstAmount,
		arg.TotalAmount,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.InvoiceNumber,
		&i.PeriodType,
		&i.PeriodStartDate,
		&i.PeriodEndDate,
		&i.SubtotalAmount,
		&i.GstAmount,
		&i.TotalAmount,
		&i.GeneratedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM invoices
WHERE id = ?1
`

func (q *Queries) DeleteInvoice(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteInvoice, id)
	return err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
WHERE i.id = ?1
`

type GetInvoiceByIDRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetInvoiceByID(ctx context.Context, id string) (GetInvoiceByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getInvoiceByID, id)
	var i GetInvoiceByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.InvoiceNumber,
		&i.PeriodType,
		&i.PeriodStartDate,
		&i.PeriodEndDate,
		&i.SubtotalAmount,
		&i.GstAmount,
		&i.TotalAmount,
		&i.GeneratedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AmountPaid,
		&i.PaymentDate,
		&i.ClientName,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
WHERE i.invoice_number = ?1
`

type GetInvoiceByNumberRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetInvoiceByNumber(ctx context.Context, invoiceNumber string) (GetInvoiceByNumberRow, error) {
	row := q.db.QueryRowContext(ctx, getInvoiceByNumber, invoiceNumber)
	var i GetInvoiceByNumberRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.InvoiceNumber,
		&i.PeriodType,
		&i.PeriodStartDate,
		&i.PeriodEndDate,
		&i.SubtotalAmount,
		&i.GstAmount,
		&i.TotalAmount,
		&i.GeneratedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AmountPaid,
		&i.PaymentDate,
		&i.ClientName,
	)
	return i, err
}

const getInvoicesByClient = `-- name: GetInvoicesByClient :many
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
WHERE c.name = ?1
ORDER BY i.generated_date DESC
`

type GetInvoicesByClientRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetInvoicesByClient(ctx context.Context, clientName string) ([]GetInvoicesByClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvoicesByClient, clientName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesByClientRow
	for rows.Next() {
		var i GetInvoicesByClientRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.InvoiceNumber,
			&i.PeriodType,
			&i.PeriodStartDate,
			&i.PeriodEndDate,
			&i.SubtotalAmount,
			&i.GstAmount,
			&i.TotalAmount,
			&i.GeneratedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AmountPaid,
			&i.PaymentDate,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByPeriod = `-- name: GetInvoicesByPeriod :many
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
WHERE i.period_start_date = ?1 
  AND i.period_end_date = ?2
  AND i.period_type = ?3
ORDER BY c.name
`

type GetInvoicesByPeriodParams struct {
	PeriodStartDate time.Time `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time `db:"period_end_date" json:"period_end_date"`
	PeriodType      string    `db:"period_type" json:"period_type"`
}

type GetInvoicesByPeriodRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetInvoicesByPeriod(ctx context.Context, arg GetInvoicesByPeriodParams) ([]GetInvoicesByPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvoicesByPeriod, arg.PeriodStartDate, arg.PeriodEndDate, arg.PeriodType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesByPeriodRow
	for rows.Next() {
		var i GetInvoicesByPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.InvoiceNumber,
			&i.PeriodType,
			&i.PeriodStartDate,
			&i.PeriodEndDate,
			&i.SubtotalAmount,
			&i.GstAmount,
			&i.TotalAmount,
			&i.GeneratedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AmountPaid,
			&i.PaymentDate,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByPeriodAndClient = `-- name: GetInvoicesByPeriodAndClient :many
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
WHERE i.period_start_date = ?1 
  AND i.period_end_date = ?2
  AND i.period_type = ?3
  AND c.name = ?4
ORDER BY i.generated_date
`

type GetInvoicesByPeriodAndClientParams struct {
	PeriodStartDate time.Time `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time `db:"period_end_date" json:"period_end_date"`
	PeriodType      string    `db:"period_type" json:"period_type"`
	ClientName      string    `db:"client_name" json:"client_name"`
}

type GetInvoicesByPeriodAndClientRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) GetInvoicesByPeriodAndClient(ctx context.Context, arg GetInvoicesByPeriodAndClientParams) ([]GetInvoicesByPeriodAndClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvoicesByPeriodAndClient,
		arg.PeriodStartDate,
		arg.PeriodEndDate,
		arg.PeriodType,
		arg.ClientName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesByPeriodAndClientRow
	for rows.Next() {
		var i GetInvoicesByPeriodAndClientRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.InvoiceNumber,
			&i.PeriodType,
			&i.PeriodStartDate,
			&i.PeriodEndDate,
			&i.SubtotalAmount,
			&i.GstAmount,
			&i.TotalAmount,
			&i.GeneratedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AmountPaid,
			&i.PaymentDate,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByInvoiceID = `-- name: GetSessionsByInvoiceID :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, s.invoice_id, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.invoice_id = ?1
ORDER BY s.start_time
`

type GetSessionsByInvoiceIDRow struct {
	ID              string              `db:"id" json:"id"`
	ClientID        string              `db:"client_id" json:"client_id"`
	StartTime       time.Time           `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime        `db:"end_time" json:"end_time"`
	Description     sql.NullString      `db:"description" json:"description"`
	CreatedAt       time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time           `db:"updated_at" json:"updated_at"`
	HourlyRate      decimal.NullDecimal `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString      `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString      `db:"outside_git" json:"outside_git"`
	InvoiceID       sql.NullString      `db:"invoice_id" json:"invoice_id"`
	ClientName      string              `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsByInvoiceID(ctx context.Context, invoiceID sql.NullString) ([]GetSessionsByInvoiceIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByInvoiceID, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsByInvoiceIDRow
	for rows.Next() {
		var i GetSessionsByInvoiceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.InvoiceID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsForPeriodWithoutInvoice = `-- name: GetSessionsForPeriodWithoutInvoice :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, s.invoice_id, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.start_time >= ?1 
  AND s.start_time <= ?2
  AND s.end_time IS NOT NULL
  AND s.invoice_id IS NULL
ORDER BY c.name, s.start_time
`

type GetSessionsForPeriodWithoutInvoiceParams struct {
	StartDate time.Time `db:"start_date" json:"start_date"`
	EndDate   time.Time `db:"end_date" json:"end_date"`
}

type GetSessionsForPeriodWithoutInvoiceRow struct {
	ID              string              `db:"id" json:"id"`
	ClientID        string              `db:"client_id" json:"client_id"`
	StartTime       time.Time           `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime        `db:"end_time" json:"end_time"`
	Description     sql.NullString      `db:"description" json:"description"`
	CreatedAt       time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time           `db:"updated_at" json:"updated_at"`
	HourlyRate      decimal.NullDecimal `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString      `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString      `db:"outside_git" json:"outside_git"`
	InvoiceID       sql.NullString      `db:"invoice_id" json:"invoice_id"`
	ClientName      string              `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsForPeriodWithoutInvoice(ctx context.Context, arg GetSessionsForPeriodWithoutInvoiceParams) ([]GetSessionsForPeriodWithoutInvoiceRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsForPeriodWithoutInvoice, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsForPeriodWithoutInvoiceRow
	for rows.Next() {
		var i GetSessionsForPeriodWithoutInvoiceRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.InvoiceID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsForPeriodWithoutInvoiceByClient = `-- name: GetSessionsForPeriodWithoutInvoiceByClient :many
SELECT s.id, s.client_id, s.start_time, s.end_time, s.description, s.created_at, s.updated_at, s.hourly_rate, s.full_work_summary, s.outside_git, s.invoice_id, c.name as client_name
FROM sessions s
JOIN clients c ON s.client_id = c.id
WHERE s.start_time >= ?1 
  AND s.start_time <= ?2
  AND s.end_time IS NOT NULL
  AND s.invoice_id IS NULL
  AND c.name = ?3
ORDER BY s.start_time
`

type GetSessionsForPeriodWithoutInvoiceByClientParams struct {
	StartDate  time.Time `db:"start_date" json:"start_date"`
	EndDate    time.Time `db:"end_date" json:"end_date"`
	ClientName string    `db:"client_name" json:"client_name"`
}

type GetSessionsForPeriodWithoutInvoiceByClientRow struct {
	ID              string              `db:"id" json:"id"`
	ClientID        string              `db:"client_id" json:"client_id"`
	StartTime       time.Time           `db:"start_time" json:"start_time"`
	EndTime         sql.NullTime        `db:"end_time" json:"end_time"`
	Description     sql.NullString      `db:"description" json:"description"`
	CreatedAt       time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time           `db:"updated_at" json:"updated_at"`
	HourlyRate      decimal.NullDecimal `db:"hourly_rate" json:"hourly_rate"`
	FullWorkSummary sql.NullString      `db:"full_work_summary" json:"full_work_summary"`
	OutsideGit      sql.NullString      `db:"outside_git" json:"outside_git"`
	InvoiceID       sql.NullString      `db:"invoice_id" json:"invoice_id"`
	ClientName      string              `db:"client_name" json:"client_name"`
}

func (q *Queries) GetSessionsForPeriodWithoutInvoiceByClient(ctx context.Context, arg GetSessionsForPeriodWithoutInvoiceByClientParams) ([]GetSessionsForPeriodWithoutInvoiceByClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsForPeriodWithoutInvoiceByClient, arg.StartDate, arg.EndDate, arg.ClientName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsForPeriodWithoutInvoiceByClientRow
	for rows.Next() {
		var i GetSessionsForPeriodWithoutInvoiceByClientRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HourlyRate,
			&i.FullWorkSummary,
			&i.OutsideGit,
			&i.InvoiceID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoices = `-- name: ListInvoices :many
SELECT i.id, i.client_id, i.invoice_number, i.period_type, i.period_start_date, i.period_end_date, i.subtotal_amount, i.gst_amount, i.total_amount, i.generated_date, i.created_at, i.updated_at, i.amount_paid, i.payment_date, c.name as client_name
FROM v_invoices i
JOIN clients c ON i.client_id = c.id
ORDER BY i.generated_date DESC
LIMIT ?1
`

type ListInvoicesRow struct {
	ID              string          `db:"id" json:"id"`
	ClientID        string          `db:"client_id" json:"client_id"`
	InvoiceNumber   string          `db:"invoice_number" json:"invoice_number"`
	PeriodType      string          `db:"period_type" json:"period_type"`
	PeriodStartDate time.Time       `db:"period_start_date" json:"period_start_date"`
	PeriodEndDate   time.Time       `db:"period_end_date" json:"period_end_date"`
	SubtotalAmount  decimal.Decimal `db:"subtotal_amount" json:"subtotal_amount"`
	GstAmount       decimal.Decimal `db:"gst_amount" json:"gst_amount"`
	TotalAmount     decimal.Decimal `db:"total_amount" json:"total_amount"`
	GeneratedDate   time.Time       `db:"generated_date" json:"generated_date"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	AmountPaid      float64         `db:"amount_paid" json:"amount_paid"`
	PaymentDate     interface{}     `db:"payment_date" json:"payment_date"`
	ClientName      string          `db:"client_name" json:"client_name"`
}

func (q *Queries) ListInvoices(ctx context.Context, limitCount int64) ([]ListInvoicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listInvoices, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInvoicesRow
	for rows.Next() {
		var i ListInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.InvoiceNumber,
			&i.PeriodType,
			&i.PeriodStartDate,
			&i.PeriodEndDate,
			&i.SubtotalAmount,
			&i.GstAmount,
			&i.TotalAmount,
			&i.GeneratedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AmountPaid,
			&i.PaymentDate,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payInvoice = `-- name: PayInvoice :exec
INSERT INTO payments (id, invoice_id, amount, payment_date)
VALUES (?1, ?2, ?3, ?4)
`

type PayInvoiceParams struct {
	ID          string          `db:"id" json:"id"`
	InvoiceID   string          `db:"invoice_id" json:"invoice_id"`
	Amount      decimal.Decimal `db:"amount" json:"amount"`
	PaymentDate time.Time       `db:"payment_date" json:"payment_date"`
}

func (q *Queries) PayInvoice(ctx context.Context, arg PayInvoiceParams) error {
	_, err := q.db.ExecContext(ctx, payInvoice,
		arg.ID,
		arg.InvoiceID,
		arg.Amount,
		arg.PaymentDate,
	)
	return err
}

const updateSessionInvoiceID = `-- name: UpdateSessionInvoiceID :exec
UPDATE sessions
SET invoice_id = ?1
WHERE id = ?2
`

type UpdateSessionInvoiceIDParams struct {
	InvoiceID sql.NullString `db:"invoice_id" json:"invoice_id"`
	SessionID string         `db:"session_id" json:"session_id"`
}

func (q *Queries) UpdateSessionInvoiceID(ctx context.Context, arg UpdateSessionInvoiceIDParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionInvoiceID, arg.InvoiceID, arg.SessionID)
	return err
}
